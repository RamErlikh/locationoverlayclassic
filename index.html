<!DOCTYPE html><html><head><meta charset="utf-8">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
  <style>
  body {
    background: transparent !important;
  }
  .text-shadow {
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 4px #000, 0 0 1px #000, 0 0 12px #000;
  }
  .info-icon {
    width: 30px;
    text-align: center;
  }
  
  .weather-icon {
    position: relative;
    display: inline-block;
  }
  
  .weather-icon-main {
    color: white;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 4px #000, 0 0 1px #000, 0 0 12px #000;
  }
  
  .heat-waves {
    position: absolute;
    top: 25px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 12px;
    animation: heatWave 2s ease-in-out infinite;
  }
  
  .heat-waves.with-wind {
    left: 1%;
  }
  
  @keyframes heatWave {
    0%, 100% { transform: translateX(-50%) translateY(0px); opacity: 0.7; }
    50% { transform: translateX(-50%) translateY(-2px); opacity: 1; }
  }
  
  .wind-waves {
    position: absolute;
    top: 25px;
    left: 97%;
    transform: translateX(-50%);
    font-size: 10px;
    animation: windWave 1.5s ease-in-out infinite;
  }
  
  .wind-waves.only-wind {
    left: 50%;
  }
  
  @keyframes windWave {
    0%, 100% { transform: translateX(-50%) translateY(0px); opacity: 0.8; }
    50% { transform: translateX(-50%) translateY(-2px); opacity: 1; }
  }
  
  .icon-text-shadow {
    color: white;
    font-size: 1.3em;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 0 4px #000, 0 0 1px #000, 0 0 12px #000;
  }
  
  .weather-row {
    margin-top: -4.25px;
  }
  </style></head><body class="text-white">
  
  <div id="info" class="position-absolute top-0 start-0 m-2 d-flex flex-column gap-1 p-3 rounded">
    <div class="d-flex align-items-center fs-5 fw-bold text-shadow text-nowrap"><i class="fa-regular fa-clock info-icon icon-text-shadow me-2"></i><span id="time">--:--:--</span></div>
    <div class="d-flex align-items-center fs-5 fw-bold text-shadow text-nowrap">
      <i class="fa-solid fa-location-dot info-icon icon-text-shadow me-2"></i>
      <span id="place">Waiting…</span>
    </div>
    <div class="d-flex align-items-center fs-5 fw-bold text-shadow text-nowrap weather-row">
      <span class="info-icon me-2">
        <span id="weather-icon" class="weather-icon">
          <i id="weather-icon-main" class="fa-solid fa-cloud weather-icon-main"></i>
          <i id="heat-waves" class="fa-solid fa-water heat-waves" style="display: none;"></i>
          <i id="wind-waves" class="fa-solid fa-wind wind-waves" style="display: none;"></i>
        </span>
      </span>
      <span id="weather">--°C</span>
    </div>
  </div>
  
  <script>
  const placeEl = document.getElementById('place');
  const weatherEl = document.getElementById('weather');
  const GOOGLE_GEO_KEY = 'AIzaSyBFwxZu_EqPgs7pEqk1uHn1f46F6vUoEFU';
  
  let lastKnownLocation = null;
  let gpsSuccessful = false;
  let gpsAttempted = false;
  let consecutiveGPSFailures = 0;
  
  // Detect if we're on mobile
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  
  // Detect if we're in an app environment (like PRISM Live)
  const isInApp = !window.location.href.startsWith('http') || 
                  window.navigator.standalone === true ||
                  window.matchMedia('(display-mode: standalone)').matches ||
                  document.referrer.includes('android-app://') ||
                  /wv|WebView/i.test(navigator.userAgent) ||
                  navigator.userAgent.includes('PRISM') ||
                  navigator.userAgent.includes('Live') ||
                  navigator.userAgent.includes('NAVER') ||
                  window.location.protocol === 'file:' ||
                  window.location.hostname === '' ||
                  !window.location.hostname ||
                  window.location.href.includes('prism') ||
                  window.location.href.includes('live') ||
                  // More aggressive detection for streaming apps
                  window.outerWidth === window.innerWidth ||
                  window.chrome === undefined ||
                  !window.chrome;
  
  function tick(){
    const now = new Date();
    const dateString = now.toLocaleDateString('en-GB', { year: 'numeric', month: '2-digit', day: '2-digit' });
    const timeString = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
    
    document.getElementById('time').textContent = `${dateString}, ${timeString}`;
  }
  tick(); setInterval(tick, 1000);
  
  async function reverseGeocode(lat, lon){
    try {
      // Use Google's reverse geocoding API for better English translations
      const res = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lon}&key=${GOOGLE_GEO_KEY}&language=en&result_type=locality|administrative_area_level_1|country`);
      const data = await res.json();
      
      if (data.status === 'OK' && data.results.length > 0) {
        const result = data.results[0];
        const components = result.address_components;
        
        // Extract components in preferred order
        let city = '';
        let state = '';
        let country = '';
        let isJapan = false;
        
        components.forEach(component => {
          const types = component.types;
          const name = component.long_name;
          
          // Debug logging
          console.log('Component:', name, 'Types:', types);
          
          // Check if location is in Japan
          if (types.includes('country') && (component.short_name === 'JP' || name === 'Japan')) {
            isJapan = true;
          }
          
          // Filter out specific district/dong names that are too detailed
          const isDetailedDistrict = name.includes('-dong') || name.includes('dong,') || name.includes('(') || name.includes(')');
          
          if (types.includes('locality') && !isDetailedDistrict) {
            console.log('Setting city to:', name);
            city = name;
          } else if (types.includes('administrative_area_level_1') && !isDetailedDistrict) {
            console.log('Setting state to:', name);
            state = name;
          } else if (types.includes('country')) {
            console.log('Setting country to:', name);
            country = name;
          }
        });
        
        // Store Japan status globally for weather icon selection
        window.isLocationInJapan = isJapan;
        
        // If we filtered out the city due to detailed district, try to find a better one
        if (!city) {
          components.forEach(component => {
            const types = component.types;
            const name = component.long_name;
            
            // Look for administrative_area_level_1 or other broader locality types
            if (types.includes('administrative_area_level_1') && name !== state) {
              city = name;
            } else if (types.includes('locality') && !name.includes('-dong') && !name.includes('(')) {
              city = name;
            }
          });
        }
        
        // Smart redundancy removal
        function areLocationsSimilar(loc1, loc2) {
          if (!loc1 || !loc2) return false;
          
          // Exact match
          if (loc1 === loc2) return true;
          
          // One contains the other (case insensitive)
          const l1 = loc1.toLowerCase();
          const l2 = loc2.toLowerCase();
          if (l1.includes(l2) || l2.includes(l1)) return true;
          
          // Check for common administrative redundancy patterns
          const adminPatterns = [
            { shorter: l1, longer: l2 + ' region' },
            { shorter: l1, longer: l2 + ' province' },
            { shorter: l1, longer: l2 + ' state' },
            { shorter: l1, longer: l2 + ' prefecture' },
            { shorter: l1, longer: l2 + ' district' },
            { shorter: l2, longer: l1 + ' region' },
            { shorter: l2, longer: l1 + ' province' },
            { shorter: l2, longer: l1 + ' state' },
            { shorter: l2, longer: l1 + ' prefecture' },
            { shorter: l2, longer: l1 + ' district' }
          ];
          
          return adminPatterns.some(pattern => 
            pattern.shorter === pattern.longer.replace(/\s+(region|province|state|prefecture|district)$/, '')
          );
        }
        
        // Remove redundant components
        if (areLocationsSimilar(city, state)) {
          console.log('Detected redundant city/state:', city, '/', state);
          // Keep the more specific one (usually the shorter one, or the one without administrative terms)
          if (city.length <= state.length && !city.toLowerCase().includes('region') && 
              !city.toLowerCase().includes('province') && !city.toLowerCase().includes('state')) {
            state = ''; // Keep city, remove state
            console.log('Keeping city:', city, 'removing state');
          } else {
            city = ''; // Keep state as city, remove redundant city
            console.log('Using state as city:', state);
          }
        }
        
        // If city is empty after redundancy check, use state as city
        if (!city && state) {
          city = state;
          state = '';
          console.log('Using state as city after redundancy check:', city);
        }
        
        // Build address string, prioritizing the most specific location
        const parts = [
          city,
          state,
          country
        ].filter(Boolean);
        
        console.log('Final location parts:', parts);
        return parts.join(", ");
      }
      
      // Safer fallback - extract only city, state, country from formatted address
      if (data.results.length > 0) {
        const formattedAddr = data.results[0].formatted_address;
        const addressParts = formattedAddr.split(', ');
        
        // Try to extract only the broader location components (last 2-3 parts typically)
        // Skip detailed addresses like street numbers, building names, etc.
        const broadParts = addressParts.slice(-3).filter(part => {
          // Filter out postal codes, detailed street addresses
          return !part.match(/^\d+/) && // No leading numbers
                 !part.includes('#') && // No building numbers
                 !part.includes('Suite') && // No suite numbers
                 !part.includes('Floor') && // No floor numbers
                 part.length > 2; // Reasonable length
        });
        
        // Additional redundancy check for formatted address parts
        const filteredParts = [];
        broadParts.forEach((part, index) => {
          const isRedundant = filteredParts.some(existingPart => {
            const p1 = part.toLowerCase();
            const p2 = existingPart.toLowerCase();
            return p1.includes(p2) || p2.includes(p1) || 
                   p1.replace(/\s+(region|province|state|prefecture|district)$/, '') === p2 ||
                   p2.replace(/\s+(region|province|state|prefecture|district)$/, '') === p1;
          });
          
          if (!isRedundant) {
            filteredParts.push(part);
          }
        });
        
        return filteredParts.join(", ");
      }
      
      throw new Error('No results from Google Geocoding');
      
    } catch (error) {
      console.warn('Google geocoding failed, falling back to Nominatim:', error);
      
      // Fallback to Nominatim with additional language parameters
      const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en&addressdetails=1&extratags=1`);
      const geo = await res.json();
      const addr = geo.address;
      
      console.log('Nominatim address components:', addr);
      
      // Check if Japan in Nominatim response
      window.isLocationInJapan = addr.country_code === 'jp' || addr.country === 'Japan' || addr.country === '日本';
      
      // Smart city name selection - avoid administrative names
      let city = '';
      let state = '';
      let country = addr.country || '';
      
      // Prefer village/town over city if city contains administrative terms
      if (addr.village && !addr.village.includes('Capital') && !addr.village.includes('City of')) {
        city = addr.village;
      } else if (addr.town && !addr.town.includes('Capital') && !addr.town.includes('City of')) {
        city = addr.town;
      } else if (addr.city && !addr.city.includes('Capital') && !addr.city.includes('City of')) {
        city = addr.city;
      } else if (addr.state && addr.state !== addr.city) {
        // If city has administrative terms, use state as city if they're different
        city = addr.state;
        state = ''; // Don't duplicate
      } else {
        // Last resort - clean up the city name
        city = (addr.city || addr.town || addr.village || '').replace(/^Capital City of /, '');
      }
      
      // Only set state if it's different from city and doesn't contain administrative terms
      if (addr.state && addr.state !== city && !addr.state.includes('Capital') && !addr.state.includes('City of')) {
        // Check for redundancy with Nominatim data too
        const cityLower = city.toLowerCase();
        const stateLower = addr.state.toLowerCase();
        
        const isRedundant = cityLower === stateLower ||
                           cityLower.includes(stateLower) || 
                           stateLower.includes(cityLower) ||
                           cityLower === stateLower.replace(/\s+(region|province|state|prefecture|district)$/, '') ||
                           stateLower === cityLower.replace(/\s+(region|province|state|prefecture|district)$/, '');
        
        if (!isRedundant) {
          state = addr.state;
        } else {
          console.log('Detected Nominatim redundancy between city and state:', city, '/', addr.state);
        }
      }
      
      const parts = [city, state, country].filter(Boolean);
      console.log('Nominatim final parts:', parts);
      return parts.join(", ");
    }
  }
  
  // Weather condition mapping for Open-Meteo weather codes
  const weatherCodes = {
    0: 'Clear Sky', 1: 'Mainly Clear', 2: 'Partly Cloudy', 3: 'Overcast',
    45: 'Fog', 48: 'Depositing Rime Fog', 51: 'Light Drizzle', 53: 'Moderate Drizzle', 
    55: 'Dense Drizzle', 56: 'Light Freezing Drizzle', 57: 'Dense Freezing Drizzle',
    61: 'Slight Rain', 63: 'Moderate Rain', 65: 'Heavy Rain', 66: 'Light Freezing Rain', 
    67: 'Heavy Freezing Rain', 71: 'Slight Snow', 73: 'Moderate Snow', 75: 'Heavy Snow',
    77: 'Snow Grains', 80: 'Slight Rain Showers', 81: 'Moderate Rain Showers', 
    82: 'Violent Rain Showers', 85: 'Slight Snow Showers', 86: 'Heavy Snow Showers',
    95: 'Thunderstorm', 96: 'Thunderstorm with Slight Hail', 99: 'Thunderstorm with Heavy Hail'
  };
  
  // Function to get weather icon based on weather code and time
  function getWeatherIcon(weatherCode, isDay = true, temperature = 20) {
    const iconMap = {
      // Clear/Sunny - use sun for day, moon for night
      0: isDay ? (temperature > 17 ? 'fa-sun' : 'fa-sun') : 'fa-moon',           // Clear Sky
      1: isDay ? 'fa-sun' : 'fa-moon',           // Mainly Clear
      
      // Cloudy
      2: isDay ? 'fa-cloud-sun' : 'fa-cloud-moon',     // Partly Cloudy
      3: 'fa-cloud',         // Overcast
      
      // Fog
      45: 'fa-eye-slash',    // Fog
      48: 'fa-eye-slash',    // Depositing Rime Fog
      
      // Drizzle
      51: 'fa-cloud-rain',   // Light Drizzle
      53: 'fa-cloud-rain',   // Moderate Drizzle
      55: 'fa-cloud-rain',   // Dense Drizzle
      56: 'fa-cloud-rain',   // Light Freezing Drizzle
      57: 'fa-cloud-rain',   // Dense Freezing Drizzle
      
      // Rain
      61: 'fa-cloud-rain',   // Slight Rain
      63: 'fa-cloud-rain',   // Moderate Rain
      65: 'fa-cloud-showers-heavy',   // Heavy Rain
      66: 'fa-cloud-rain',   // Light Freezing Rain
      67: 'fa-cloud-showers-heavy',   // Heavy Freezing Rain
      
      // Snow
      71: 'fa-snowflake',    // Slight Snow
      73: 'fa-snowflake',    // Moderate Snow
      75: 'fa-snowflake',    // Heavy Snow
      77: 'fa-snowflake',    // Snow Grains
      
      // Showers
      80: 'fa-cloud-rain',   // Slight Rain Showers
      81: 'fa-cloud-rain',   // Moderate Rain Showers
      82: 'fa-cloud-showers-heavy',   // Violent Rain Showers
      85: 'fa-snowflake',    // Slight Snow Showers
      86: 'fa-snowflake',    // Heavy Snow Showers
      
      // Thunderstorm
      95: 'fa-cloud-bolt',         // Thunderstorm
      96: 'fa-cloud-bolt',         // Thunderstorm with Slight Hail
      99: 'fa-cloud-bolt'          // Thunderstorm with Heavy Hail
    };
    
    return iconMap[weatherCode] || 'fa-cloud';
  }
  
  // Enhanced heat wave detection based on regional climate context
  function determineHeatWaveThreshold(lat) {
    // Regional temperature thresholds based on latitude and typical climate zones
    const tempThresholds = {
      // Arctic/Subarctic (above 60°N)
      arctic: { threshold: 20, region: 'Arctic' },
      // Northern temperate (45-60°N)  
      northTemperate: { threshold: 28, region: 'Northern Temperate' },
      // Mid temperate (30-45°N)
      midTemperate: { threshold: 32, region: 'Mid Temperate' },
      // Subtropical (15-30°N)
      subtropical: { threshold: 35, region: 'Subtropical' },
      // Tropical (0-15°N)
      tropical: { threshold: 38, region: 'Tropical' },
      // Southern hemisphere equivalents
      southTropical: { threshold: 38, region: 'South Tropical' },
      southSubtropical: { threshold: 35, region: 'South Subtropical' },
      southTemperate: { threshold: 32, region: 'South Temperate' }
    };
    
    const absLat = Math.abs(lat);
    
    if (absLat >= 60) return tempThresholds.arctic;
    if (absLat >= 45) return lat > 0 ? tempThresholds.northTemperate : tempThresholds.southTemperate;
    if (absLat >= 30) return tempThresholds.midTemperate;
    if (absLat >= 15) return lat > 0 ? tempThresholds.subtropical : tempThresholds.southSubtropical;
    return lat > 0 ? tempThresholds.tropical : tempThresholds.southTropical;
  }
  
  async function fetchWeather(lat, lon){
    try {
      // Enhanced API call with additional parameters for better condition detection
      const r = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code,is_day,wind_speed_10m,precipitation,visibility&timezone=auto`);
      const j = await r.json();
      const c = Math.round(j.current.temperature_2m);
      const f = Math.round(c * 9 / 5 + 32);
      const isDay = j.current.is_day === 1;
      
      // Enhanced weather condition detection
      const windSpeed = j.current.wind_speed_10m || 0;
      const precipitation = j.current.precipitation || 0;
      const visibility = j.current.visibility || 10000;
      
      // Wind conditions
      let isWindy = windSpeed > 18;
      let isVeryWindy = windSpeed > 35;
      
      let desc = weatherCodes[j.current.weather_code] || 'Unknown';
      
      // Change "Clear Sky" to "Sunny" if temperature is above 17°C and it's daytime
      if (j.current.weather_code === 0 && c > 17 && isDay) {
        desc = 'Sunny';
      }
      
      // Get regional heat wave threshold
      const heatThreshold = determineHeatWaveThreshold(lat);
      console.log(`Heat wave threshold for region (${heatThreshold.region}): ${heatThreshold.threshold}°C`);
      
      // Check for heat wave conditions
      const isHot = c >= heatThreshold.threshold;
      
      // Add wind description to weather text if windy
      if (isVeryWindy) {
        desc += ', Very Windy';
      } else if (isWindy) {
        desc += ', Windy';
      }
      
      // Add heat wave description if applicable
      if (isHot) {
        desc += ', Heat Wave';
      }
      
      weatherEl.textContent = `${c}°C | ${f}°F, ${desc}`;
      
      // Update weather icon
      const weatherIconMain = document.getElementById('weather-icon-main');
      const heatWaves = document.getElementById('heat-waves');
      const windWaves = document.getElementById('wind-waves');
      const iconClass = getWeatherIcon(j.current.weather_code, isDay, c);
      
      // Remove all existing weather icon classes
      weatherIconMain.className = 'weather-icon-main';
      weatherIconMain.classList.add('fa-solid', iconClass);
      
      // Show heat waves based on regional threshold
      if (heatWaves) {
        if (isHot) {
          heatWaves.style.display = 'inline-block';
          // Position based on whether wind is also showing
          if (isWindy) {
            heatWaves.classList.add('with-wind');
          } else {
            heatWaves.classList.remove('with-wind');
          }
        } else {
          heatWaves.style.display = 'none';
          heatWaves.classList.remove('with-wind');
        }
      }
      
      // Show wind waves if windy conditions
      if (windWaves) {
        if (isWindy) {
          windWaves.style.display = 'inline-block';
          
          // Position wind waves - if no heat, center it; if heat, keep it to the right
          if (isHot) {
            windWaves.classList.remove('only-wind');
            // Update heat waves to show they're with wind
            if (heatWaves) {
              heatWaves.classList.add('with-wind');
            }
          } else {
            windWaves.classList.add('only-wind');
          }
        } else {
          windWaves.style.display = 'none';
          windWaves.classList.remove('only-wind');
          
          // Remove wind class from heat waves
          if (heatWaves) {
            heatWaves.classList.remove('with-wind');
          }
        }
      }
    } catch (error) {
      console.error('Weather fetch failed:', error);
      weatherEl.textContent = "Weather N/A";
    }
  }
  
  // Method 1: Try IRL Pro location data
  function getIRLProLocation() {
    if (window.locationData && window.locationData.latitude && window.locationData.longitude) {
      return {
        lat: window.locationData.latitude,
        lon: window.locationData.longitude,
        source: "IRL Pro GPS"
      };
    }
    return null;
  }
  
  // Method 1.5: Try PRISM Live location data
  function getPRISMLocation() {
    // Check for various possible PRISM Live location interfaces
    if (window.prismLocationData && window.prismLocationData.latitude && window.prismLocationData.longitude) {
      return {
        lat: window.prismLocationData.latitude,
        lon: window.prismLocationData.longitude,
        source: "PRISM Live GPS"
      };
    }
    
    // Alternative PRISM Live interfaces
    if (window.prism && window.prism.location && window.prism.location.latitude && window.prism.location.longitude) {
      return {
        lat: window.prism.location.latitude,
        lon: window.prism.location.longitude,
        source: "PRISM Live GPS"
      };
    }
    
    // Check for PRISM Live GPS data in different format
    if (window.PRISM_GPS && window.PRISM_GPS.lat && window.PRISM_GPS.lon) {
      return {
        lat: window.PRISM_GPS.lat,
        lon: window.PRISM_GPS.lon,
        source: "PRISM Live GPS"
      };
    }
    
    // Check webkit message handlers (common in mobile apps)
    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.locationHandler) {
      // This would require a callback mechanism, but we can try to access cached data
      if (window.webkit.lastKnownLocation && window.webkit.lastKnownLocation.latitude && window.webkit.lastKnownLocation.longitude) {
        return {
          lat: window.webkit.lastKnownLocation.latitude,
          lon: window.webkit.lastKnownLocation.longitude,
          source: "PRISM Live GPS (WebKit)"
        };
      }
    }
    
    // Check for Android interface
    if (window.Android && window.Android.getLatitude && window.Android.getLongitude) {
      try {
        const lat = parseFloat(window.Android.getLatitude());
        const lon = parseFloat(window.Android.getLongitude());
        if (!isNaN(lat) && !isNaN(lon) && lat !== 0 && lon !== 0) {
          return {
            lat: lat,
            lon: lon,
            source: "PRISM Live GPS (Android)"
          };
        }
      } catch (e) {
        console.warn('Android location interface failed:', e);
      }
    }
    
    return null;
  }
  
  // Method 1.6: Actively request location from PRISM Live
  function requestPRISMLocation() {
    return new Promise((resolve, reject) => {
      let resolved = false;
      
      // Set timeout to avoid hanging
      const timeout = setTimeout(() => {
        if (!resolved) {
          resolved = true;
          reject(new Error('PRISM Live location request timeout'));
        }
      }, 5000);
      
      // Try WebKit message handler
      if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.locationHandler) {
        try {
          window.webkit.messageHandlers.locationHandler.postMessage({action: 'getCurrentLocation'});
          
          // Set up listener for response
          window.prismLocationCallback = function(locationData) {
            if (!resolved && locationData && locationData.latitude && locationData.longitude) {
              resolved = true;
              clearTimeout(timeout);
              resolve({
                lat: locationData.latitude,
                lon: locationData.longitude,
                source: "PRISM Live GPS (Requested)"
              });
            }
          };
          
          // Also check if location is immediately available
          setTimeout(() => {
            const location = getPRISMLocation();
            if (!resolved && location) {
              resolved = true;
              clearTimeout(timeout);
              resolve(location);
            }
          }, 100);
          
        } catch (e) {
          console.warn('WebKit location request failed:', e);
        }
      }
      
      // Try Android interface
      if (window.Android && window.Android.requestLocation) {
        try {
          window.Android.requestLocation();
          
          // Check for location after a brief delay
          setTimeout(() => {
            const location = getPRISMLocation();
            if (!resolved && location) {
              resolved = true;
              clearTimeout(timeout);
              resolve(location);
            }
          }, 1000);
          
        } catch (e) {
          console.warn('Android location request failed:', e);
        }
      }
      
      // Try posting messages to parent frame (if in iframe)
      try {
        window.parent.postMessage({type: 'requestLocation'}, '*');
        window.postMessage({type: 'requestLocation'}, '*');
        
        // Listen for response
        const messageListener = function(event) {
          if (!resolved && event.data && event.data.type === 'locationResponse' && event.data.latitude && event.data.longitude) {
            resolved = true;
            clearTimeout(timeout);
            window.removeEventListener('message', messageListener);
            resolve({
              lat: event.data.latitude,
              lon: event.data.longitude,
              source: "PRISM Live GPS (Message)"
            });
          }
        };
        window.addEventListener('message', messageListener);
        
      } catch (e) {
        console.warn('Message-based location request failed:', e);
      }
      
      // If no specific interface worked, reject after timeout
      setTimeout(() => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          reject(new Error('No PRISM Live location interface found'));
        }
      }, 2000);
    });
  }
  
  // Method 2: Try browser GPS
  function getBrowserGPS(showLoadingMessages = true) {
    return new Promise((resolve, reject) => {
      console.log('getBrowserGPS called, isInApp:', isInApp, 'showLoadingMessages:', showLoadingMessages);
      
      // Skip GPS entirely in app environments
      if (isInApp) {
        console.log('GPS skipped - in app environment');
        reject(new Error('GPS skipped - in app environment'));
        return;
      }
      
      if (!navigator.geolocation) {
        console.log('Geolocation not supported');
        reject(new Error('Geolocation not supported'));
        return;
      }
  
      if (showLoadingMessages) {
        console.log('Setting GPS loading message');
        placeEl.textContent = "Grabbing GPS Location...";
      }
      
      const options = {
        enableHighAccuracy: true,
        timeout: isIOS ? 60000 : (isMobile ? 45000 : 15000),
        maximumAge: gpsSuccessful ? 30000 : 0
      };
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          gpsSuccessful = true;
          consecutiveGPSFailures = 0;
          resolve({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: Math.round(position.coords.accuracy),
            source: `GPS (±${Math.round(position.coords.accuracy)}m)`
          });
        },
        (error) => {
          consecutiveGPSFailures++;
          reject(error);
        },
        options
      );
    });
  }
  
  // Method 3: Fallback to IP location with multiple services
  async function getLocationFromGoogle(){
    try {
      const res = await fetch("https://www.googleapis.com/geolocation/v1/geolocate?key=" + GOOGLE_GEO_KEY, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ considerIp: true })
      });
      
      if (!res.ok) {
        throw new Error(`Google Geolocation API failed: ${res.status} ${res.statusText}`);
      }
      
      const data = await res.json();
      
      if (data.error) {
        throw new Error(`Google Geolocation API error: ${data.error.message}`);
      }
      
      return {
        lat: data.location.lat,
        lon: data.location.lng,
        source: "IP Location (Google)"
      };
    } catch (error) {
      // Don't log CORS errors as they're expected when opening HTML files locally
      if (!error.message.includes('CORS') && !error.message.includes('403')) {
        console.warn('Google IP location failed:', error.message);
      }
      throw error;
    }
  }

  // Alternative IP location services
  async function getIPLocationFromIpApi() {
    try {
      const res = await fetch('https://ip-api.com/json/?fields=status,lat,lon');
      
      if (!res.ok) {
        throw new Error(`IP-API failed: ${res.status} ${res.statusText}`);
      }
      
      const data = await res.json();
      
      if (data.status !== 'success') {
        throw new Error('IP-API request failed');
      }
      
      return {
        lat: data.lat,
        lon: data.lon,
        source: "IP Location (IP-API)"
      };
    } catch (error) {
      // Don't log CORS errors as they're expected when opening HTML files locally
      if (!error.message.includes('CORS') && !error.message.includes('403')) {
        console.warn('IP-API location failed:', error.message);
      }
      throw error;
    }
  }

  async function getIPLocationFromIpInfo() {
    try {
      const res = await fetch('https://ipinfo.io/json');
      
      if (!res.ok) {
        throw new Error(`IPInfo failed: ${res.status} ${res.statusText}`);
      }
      
      const data = await res.json();
      
      if (!data.loc) {
        throw new Error('IPInfo request failed - no location data');
      }
      
      const [lat, lon] = data.loc.split(',').map(Number);
      return {
        lat: lat,
        lon: lon,
        source: "IP Location (IPInfo)"
      };
    } catch (error) {
      // Don't log CORS errors as they're expected when opening HTML files locally
      if (!error.message.includes('CORS') && !error.message.includes('403')) {
        console.warn('IPInfo location failed:', error.message);
      }
      throw error;
    }
  }

  async function getIPLocationFromIpApi2() {
    try {
      const res = await fetch('https://ipapi.co/json/');
      
      if (!res.ok) {
        throw new Error(`IPAPI.co failed: ${res.status} ${res.statusText}`);
      }
      
      const data = await res.json();
      
      if (data.error) {
        throw new Error(`IPAPI.co error: ${data.reason}`);
      }
      
      return {
        lat: data.latitude,
        lon: data.longitude,
        source: "IP Location (IPAPI.co)"
      };
    } catch (error) {
      // Don't log CORS errors as they're expected when opening HTML files locally
      if (!error.message.includes('CORS') && !error.message.includes('403')) {
        console.warn('IPAPI.co location failed:', error.message);
      }
      throw error;
    }
  }

  // Try multiple IP location services in order
  async function getIPLocation() {
    const services = [
      getLocationFromGoogle,
      getIPLocationFromIpApi,
      getIPLocationFromIpInfo,
      getIPLocationFromIpApi2
    ];

    for (const service of services) {
      try {
        const result = await service();
        console.log('IP location success:', result.source);
        return result;
      } catch (error) {
        console.warn('IP location service failed, trying next...', error);
        continue;
      }
    }
    
    throw new Error('All IP location services failed');
  }
  
  async function updateLocationAndWeather(showLoadingMessages = true){
    try {
      let locationData = null;
      
      // Try Method 1: IRL Pro location data
      locationData = getIRLProLocation();
      
      // Try Method 1.5: Try PRISM Live location data
      if (!locationData) {
        locationData = getPRISMLocation();
      }
      
      // Try Method 1.6: Actively request location from PRISM Live
      if (!locationData) {
        try {
          locationData = await requestPRISMLocation();
        } catch (prismError) {
          console.warn('PRISM Live location request failed:', prismError);
        }
      }
      
      // Try Method 2: Browser GPS - Allow retries even after previous failures (but skip in app environments)
      if (!locationData && !isInApp) {
        try {
          locationData = await getBrowserGPS(showLoadingMessages);
          gpsAttempted = true;
        } catch (gpsError) {
          console.warn('GPS failed:', gpsError);
          gpsAttempted = true;
        }
      }
      
      // Try Method 3: IP location fallback
      if (!locationData) {
        if (showLoadingMessages) {
          placeEl.textContent = "Loading location...";
        }
        try {
          locationData = await getIPLocation();
        } catch (ipError) {
          console.error('All IP location services failed:', ipError);
        }
      }
      
      // Use last known location as final fallback (expanded conditions)
      if (!locationData && lastKnownLocation) {
        const now = Date.now();
        const locationAge = now - (lastKnownLocation.timestamp || 0);
        
        // Use cached location if it's recent (within 10 minutes) or if all methods failed
        if (locationAge < 600000) { // 10 minutes instead of 5
          locationData = lastKnownLocation;
          console.log('Using cached location (age:', Math.round(locationAge/60000), 'minutes)');
        }
      }
      
      // Update the display
      if (locationData) {
        lastKnownLocation = locationData;
        lastKnownLocation.timestamp = Date.now();
        if (showLoadingMessages) {
          placeEl.textContent = "Loading location...";
        }
        const label = await reverseGeocode(locationData.lat, locationData.lon);
        placeEl.textContent = label;
        fetchWeather(locationData.lat, locationData.lon);
        console.log('Location updated:', locationData.source, label);
      } else {
        // Only show "Location N/A" if we truly have no fallback options
        console.error('No location data available from any source');
        if (showLoadingMessages) {
          placeEl.textContent = "Location N/A";
          weatherEl.textContent = "Weather N/A";
        }
        // Don't update display during silent refreshes to avoid flashing "N/A"
      }
      
    } catch (e) {
      console.error('Location update failed:', e);
      // Only show error during initial load or user-initiated refresh
      if (showLoadingMessages) {
      placeEl.textContent = "Location N/A";
      weatherEl.textContent = "Weather N/A";
      }
    }
  }
  
  // Auto-refresh every 55 seconds (without loading messages)
  setInterval(() => updateLocationAndWeather(false), 55000);
  
  // Debug function to detect available location interfaces
  function debugLocationInterfaces() {
    console.log('=== LOCATION INTERFACE DEBUG ===');
    console.log('User Agent:', navigator.userAgent);
    console.log('Location href:', window.location.href);
    console.log('Location protocol:', window.location.protocol);
    console.log('Location hostname:', window.location.hostname);
    console.log('Window chrome:', !!window.chrome);
    console.log('Outer width:', window.outerWidth, 'Inner width:', window.innerWidth);
    console.log('IRL Pro locationData:', !!window.locationData);
    console.log('PRISM prismLocationData:', !!window.prismLocationData);
    console.log('PRISM window.prism:', !!window.prism);
    console.log('PRISM window.PRISM_GPS:', !!window.PRISM_GPS);
    console.log('WebKit messageHandlers:', !!(window.webkit && window.webkit.messageHandlers));
    console.log('Android interface:', !!window.Android);
    console.log('Navigator geolocation:', !!navigator.geolocation);
    console.log('Is in app environment:', isInApp);
    
    // Log all window properties that might be related to location
    const locationRelatedProps = [];
    for (let prop in window) {
      if (prop.toLowerCase().includes('location') || 
          prop.toLowerCase().includes('gps') || 
          prop.toLowerCase().includes('geo') ||
          prop.toLowerCase().includes('prism') ||
          prop.toLowerCase().includes('position')) {
        locationRelatedProps.push(prop + ': ' + typeof window[prop]);
      }
    }
    if (locationRelatedProps.length > 0) {
      console.log('Location-related window properties:', locationRelatedProps);
    }
    console.log('=== END DEBUG ===');
  }
  
  // Run debug on load
  setTimeout(debugLocationInterfaces, 1000);
  
  // Start immediately (with loading messages)
  updateLocationAndWeather(true);
  </script>
  </body></html> 
